import { Observable } from 'rxjs';
import { Robot } from '../../types/Robot';
import { Application } from '../../types/Application';
import { ApplicationArgsTemplate } from '../../types/ApplicationArgsTemplate';
import { FSM } from '../../types/FSM';
import { ICubEmoPart } from '../../types/ICubEmoPart';
import { ICubEmoEmotion } from '../../types/ICubEmoEmotion';
import { ICubEmoColor } from '../../types/ICubEmoColor';

export interface IApiService {
  getRobots(): Observable<Robot[]>;
  getApplications(robotName: string): Observable<Application[]>;
  getApplicationArgsTemplate(robotName: string, appName: string, appPort: string): Observable<ApplicationArgsTemplate>;
  setApplicationArgs(robotName: string, appName: string, appPort: string, args: any): Observable<any>;
  getApplicationFSM(robotName: string, appName: string, appPort: string): Observable<FSM>;
  getServices(robotName: string, appName: string): Observable<any>;
  checkAsyncRequestStatus(requestID: string, initCallback: () => void, runningCallback: () => void, doneCallback: (retval: any) => void, failedCallback: () => void): void;
  runService<T = void>(robotName: string, appName: string, appPort: string, serviceName: string, body?: any): Observable<T>;
  runServiceAsync(robotName: string, appName: string, appPort: string, serviceName: string, body?: any): Observable<string>;
  fsmGetCurrentState(robotName: string, appName: string, appPort: string): Observable<string>;
  emoAngry(robotName: string): Observable<any>;
  emoClosingEyes(robotName: string): Observable<any>;
  emoCun(robotName: string): Observable<any>;
  emoEbSmile(robotName: string): Observable<any>;
  emoEbSurprised(robotName: string): Observable<any>;
  emoEvil(robotName: string): Observable<any>;
  emoNeutral(robotName: string): Observable<any>;
  emoOpeningEyes(robotName: string): Observable<any>;
  emoSad(robotName: string): Observable<any>;
  emoSendCmd(robotName: string, part: ICubEmoPart, emotion: ICubEmoEmotion): Observable<any>;
  emoSetBrightness(robotName: string, brightness: 0 | 1 | 2 | 3 | 4 | 5): Observable<any>;
  emoSetColor(robotName: string, color: ICubEmoColor): Observable<any>;
  emoSmile(robotName: string): Observable<any>;
  emoSurprised(robotName: string): Observable<any>;
  gazeBlockEyes(robotName: string, vergence: number): Observable<any>;
  gazeBlockNeck(robotName: string): Observable<any>;
  gazeClearEyes(robotName: string): Observable<any>;
  gazeClearNeck(robotName: string): Observable<any>;
  gazeInit(robotName: string): Observable<any>;
  gazeLookAtAbsAngles(robotName: string, azimuth: number, elevation: number, vergence: number, waitMotionDone?: boolean, timeout?: number): Observable<any>;
  gazeLookAtFixationPoint(robotName: string, x: number, y: number, z: number, waitMotionDone?: boolean, timeout?: number): Observable<any>;
  gazeLookAtRelAngles(robotName: string, azimuth: number, elevation: number, vergence: number, waitMotionDone?: boolean, timeout?: number): Observable<any>;
  gazeReset(robotName: string): Observable<any>;
  gazeSetParams(robotName: string, neck_tt: number, eyes_tt: number): Observable<any>;
  gazeSetTrackingMode(robotName: string, mode: boolean): Observable<any>;
  gazeWaitMotionDone(robotName: string, period?: number, timeout?: number): Observable<any>;
  gazeWaitMotionOnset(robotName: string, speedRef?: number, period?: number, maxAttempts?: number): Observable<any>;
  speechClose(robotName: string): Observable<any>;
  speechSay(robotName: string, sentence: string, waitActionDone?: boolean): Observable<any>;
  speechSayAsync(robotName: string, sentence: string, waitActionDone?: boolean): Observable<string>;
  camLeftGetURI(robotName: string): Observable<URL>;
  camLeftGetImgRes(robotName: string): Observable<{ width: number, height: number }>;
  camRightGetImgRes(robotName: string): Observable<{ width: number, height: number }>;
  camRightGetURI(robotName: string): Observable<URL>;
  getRobotActions(robotName: string): Observable<any>;
  playAction(robotName: string, actionID: string, sync: boolean, initCallback: () => void, runningCallback: () => void, doneCallback: (retval: any) => void, failedCallback: () => void): Observable<any>;
}
